#include "gmock/gmock.h"
#include "gtest/gtest.h"

#include "SLIPPacket.hpp"

using ::testing::NiceMock;
using ::testing::StrictMock;

uint8_t rawData[] = {0x12, 0xd4, 0x1,  0xa,  0x8d, 0x1,  0x8,  0x1,  0x12, 0x88, 0x1,  0x8,  0x4,
                     0x10, 0x34, 0x1a, 0x2,  0xb7, 0x1,  0x20, 0x3,  0x28, 0xd0, 0x82, 0x9,  0x30,
                     0x90, 0xb2, 0x1,  0x38, 0x0,  0x42, 0x24, 0x8,  0x3,  0x12, 0x20, 0xed, 0xb6,
                     0x69, 0xd9, 0xf5, 0xb0, 0xcc, 0x5,  0x24, 0xe3, 0xd0, 0x1b, 0xb0, 0xef, 0xe1,
                     0xbe, 0xb1, 0x10, 0x33, 0xb0, 0x3d, 0x10, 0x56, 0xaf, 0x1f, 0xa0, 0x10, 0xa1,
                     0x77, 0x83, 0xbc, 0xfd, 0x48, 0x0,  0x52, 0x44, 0x8,  0x3,  0x12, 0x40, 0xfa,
                     0xa8, 0x59, 0x8c, 0xd,  0x4a, 0xa9, 0x4f, 0x41, 0x50, 0x1f, 0x3f, 0x42, 0x4d,
                     0x5,  0xeb, 0xf1, 0x68, 0x7c, 0xec, 0xbb, 0xfe, 0x10, 0x3e, 0x62, 0xa2, 0x5a,
                     0x1b, 0x76, 0xf,  0x12, 0x3f, 0xb5, 0x81, 0x1d, 0xa,  0xb6, 0x17, 0xd6, 0x74,
                     0xcc, 0xbc, 0xb3, 0xf2, 0x0,  0xef, 0x74, 0x57, 0x34, 0x88, 0x3c, 0x47, 0x6d,
                     0x7e, 0x42, 0xd2, 0x9b, 0x5a, 0xb2, 0xe1, 0xd8, 0x61, 0x71, 0xba, 0x52, 0x4,
                     0x8,  0x1,  0x12, 0x0,  0x10, 0x0,  0x1a, 0x40, 0xc4, 0x63, 0x49, 0x1c, 0xa5,
                     0xc,  0x96, 0xaa, 0x65, 0xca, 0x61, 0x4c, 0xe3, 0x72, 0x1,  0x5c, 0x45, 0x76,
                     0xb4, 0xd3, 0xd5, 0x11, 0x2f, 0x52, 0x38, 0x56, 0x73, 0x84, 0xdb, 0x7f, 0x4c,
                     0x1a, 0xf0, 0x4d, 0xba, 0xf5, 0x6b, 0x1a, 0x43, 0xe9, 0xd0, 0xab, 0x0,  0x27,
                     0x6f, 0x8,  0x36, 0xfd, 0xd8, 0xd6, 0x9e, 0x50, 0xe4, 0x48, 0x9c, 0x53, 0x74,
                     0x53, 0x95, 0xf3, 0x65, 0x3f, 0x2d, 0x10};

uint8_t encodedData[] =
    {0x12, 0xd4, 0x1,  0xa,  0x8d, 0x1,  0x8,  0x1,  0x12, 0x88, 0x1,  0x8,  0x4,  0x10, 0x34, 0x1a,
     0x2,  0xb7, 0x1,  0x20, 0x3,  0x28, 0xd0, 0x82, 0x9,  0x30, 0x90, 0xb2, 0x1,  0x38, 0x0,  0x42,
     0x24, 0x8,  0x3,  0x12, 0x20, 0xed, 0xb6, 0x69, 0xd9, 0xf5, 0xb0, 0xcc, 0x5,  0x24, 0xe3, 0xd0,
     0x1b, 0xb0, 0xef, 0xe1, 0xbe, 0xb1, 0x10, 0x33, 0xb0, 0x3d, 0x10, 0x56, 0xaf, 0x1f, 0xa0, 0x10,
     0xa1, 0x77, 0x83, 0xbc, 0xfd, 0x48, 0x0,  0x52, 0x44, 0x8,  0x3,  0x12, 0x40, 0xfa, 0xa8, 0x59,
     0x8c, 0xd,  0x4a, 0xa9, 0x4f, 0x41, 0x50, 0x1f, 0x3f, 0x42, 0x4d, 0x5,  0xeb, 0xf1, 0x68, 0x7c,
     0xec, 0xbb, 0xfe, 0x10, 0x3e, 0x62, 0xa2, 0x5a, 0x1b, 0x76, 0xf,  0x12, 0x3f, 0xb5, 0x81, 0x1d,
     0xa,  0xb6, 0x17, 0xd6, 0x74, 0xcc, 0xbc, 0xb3, 0xf2, 0x0,  0xef, 0x74, 0x57, 0x34, 0x88, 0x3c,
     0x47, 0x6d, 0x7e, 0x42, 0xd2, 0x9b, 0x5a, 0xb2, 0xe1, 0xd8, 0x61, 0x71, 0xba, 0x52, 0x4,  0x8,
     0x1,  0x12, 0x0,  0x10, 0x0,  0x1a, 0x40, 0xc4, 0x63, 0x49, 0x1c, 0xa5, 0xc,  0x96, 0xaa, 0x65,
     0xca, 0x61, 0x4c, 0xe3, 0x72, 0x1,  0x5c, 0x45, 0x76, 0xb4, 0xd3, 0xd5, 0x11, 0x2f, 0x52, 0x38,
     0x56, 0x73, 0x84, 0xdb, 0xdd, 0x7f, 0x4c, 0x1a, 0xf0, 0x4d, 0xba, 0xf5, 0x6b, 0x1a, 0x43, 0xe9,
     0xd0, 0xab, 0x0,  0x27, 0x6f, 0x8,  0x36, 0xfd, 0xd8, 0xd6, 0x9e, 0x50, 0xe4, 0x48, 0x9c, 0x53,
     0x74, 0x53, 0x95, 0xf3, 0x65, 0x3f, 0x2d, 0x10}; /* End of frame is not present */

class SlipPacketTest : public ::testing::Test
{
protected:
    SlipPacketTest(){};

    static constexpr uint8_t END_OF_FRAME = 0xc0;
};

TEST_F(SlipPacketTest, SimplePacket)
{
    SLIPPacket<sizeof(encodedData) + sizeof(END_OF_FRAME)> packet{};

    EXPECT_EQ(packet.createWithPayload(array_view<const uint8_t>(rawData, sizeof(rawData))) > 0,
              true);

    EXPECT_EQ(packet.size(), sizeof(encodedData) + sizeof(END_OF_FRAME));
    EXPECT_EQ(memcmp(packet.data(), encodedData, sizeof(encodedData)), 0);

    EXPECT_EQ(packet.data()[sizeof(encodedData)], END_OF_FRAME);
};

TEST_F(SlipPacketTest, MultiplePacket)
{
    const size_t chunkSize = 64;
    SLIPPacket<2 * chunkSize + 1> packet{};
    uint8_t* pRawData = rawData;
    uint8_t* pEncodedData = encodedData;
    size_t remainingSize = sizeof(rawData);
    size_t totalEncodedSize = 0;

    while(remainingSize > 0)
    {
        const size_t calculatedChunkSize = std::min(chunkSize, remainingSize);
        EXPECT_EQ(packet.createWithPayload(array_view<const uint8_t>(pRawData, calculatedChunkSize))
                      > 0,
                  true);
        EXPECT_EQ(packet.size() != 0, true);
        remainingSize -= calculatedChunkSize;
        pRawData += chunkSize;
        EXPECT_EQ(memcmp(packet.data(), pEncodedData, packet.size() - sizeof(END_OF_FRAME)), 0);
        EXPECT_EQ(packet.data()[packet.size() - sizeof(END_OF_FRAME)], END_OF_FRAME);
        pEncodedData += (packet.size() - sizeof(END_OF_FRAME));
        totalEncodedSize += (packet.size() - sizeof(END_OF_FRAME));
    };

    EXPECT_EQ(totalEncodedSize, sizeof(encodedData));
};

TEST_F(SlipPacketTest, ValidSize)
{
    std::array<uint8_t, 5> randomData = {0, 1, 2, 3, END_OF_FRAME};
    SLIPPacket<15> packet{array_view<const uint8_t>(randomData.data(), randomData.size())};

    EXPECT_EQ(packet.size(), randomData.size());
}

TEST_F(SlipPacketTest, TooBigData)
{
    std::array<uint8_t, 20> randomData;
    SLIPPacket<10> packet{array_view<const uint8_t>(randomData.data(), randomData.size())};

    EXPECT_EQ(packet.size(), 0);
}

TEST_F(SlipPacketTest, TooBigPayload)
{
    std::array<uint8_t, 20> randomData;
    SLIPPacket<10> packet{};

    EXPECT_EQ(packet.createWithPayload(
                  array_view<const uint8_t>(randomData.data(), randomData.size())),
              -1);
    EXPECT_EQ(packet.size(), 0);
};
